#pragma once

struct MaterialRecord {
  uint8_t shaderType;
  std::string inherits;
  uint32_t clamp;
  std::array<float, 2> uvOffset = {0, 0};
  std::array<float, 2> uvScale = {1, 1};
  float transparency = 1;
  bool alphaBlend = false;
  uint32_t sourceBlendMode;
  uint32_t destinationBlendMode;
  uint8_t alphaTestThreshold = 128;
  bool alphaTest;
  bool depthWrite;
  bool depthTest;
  bool ssr;
  bool wetnessControlSsr;
  bool decal;
  bool twoSided;
  bool decalNoFade;
  bool nonOccluder;
  bool refraction;
  bool refractionalFalloff;
  float refractionPower;
  bool envMapEnabled;
  float envMapMaskScale = 1.f;
  bool depthBias;
  bool grayscaleToPaletteColor;
  uint8_t maskWrites;

  // BGSM specific fields
  std::string diffuseMap;
  std::string normalMap;
  std::string smoothSpecMap;
  std::string grayscaleMap;
  std::string glowMap;
  std::string wrinkleMap;
  std::string specularMap;
  std::string lightingMap;
  std::string flowMap;
  std::string distanceFieldAlphaMap;
  std::string envMap;
  std::string innerLayerMap;
  std::string displacementMap;
  std::string baseMap;
  std::string envMapMask;
  bool enableEditorAlphaThreshold;
  bool translucency;
  bool translucencyThickObject;
  bool translucencyMixAlbedoWithSubsurfaceColor;
  std::array<uint8_t, 4> translucencySubsurfaceColor;
  float translucencyTransmissiveScale;
  float translucencyTurbulence;
  bool rimLighting;
  float rimPower;
  float backLightPower;
  bool subsurfaceLighting;
  float subsurfaceLightingRolloff;
  bool specularEnabled = true;
  std::array<uint8_t, 3> specularColor = {255, 255, 255};
  float specularMult = 1.f;
  float smoothness;
  float fresnelPower;
  float wetnessControlSpecScale;
  float wetnessControlSpecPowerScale;
  float wetnessControlSpecMinvar;
  float wetnessControlEnvMapScale;
  float wetnessControlFresnelPower;
  float wetnessControlMetalness;
  bool pbr;
  bool customPorosity;
  float porosityValue;
  std::string rootMaterialPath;
  bool anisoLighting;
  bool emitEnabled;
  std::array<uint8_t, 4> emitColor = {255, 255, 255, 255};
  float emitMult = 1;
  bool modelSpaceNormals;
  bool externalEmit;
  float lumEmit;
  bool useAdaptiveEmissive;
  std::array<float, 3> adaptiveEmissiveExposureParams;
  bool backLighting;
  bool receiveShadows = true;
  bool hideSecret;
  bool castShadows = true;
  bool dissolveFade;
  bool assumeShadowmask;
  bool glowMapEnabled;
  bool envMapWindow;
  bool envMapEye;
  bool hair;
  std::array<float, 3> hairTintColor = {128, 128, 128};
  bool tree;
  bool facegen;
  bool skinTint;
  bool tessellate;
  std::array<float, 2> displacementMapParams;
  std::array<float, 3> tessellationParams;
  float grayscaleToPaletteScale;
  bool skewSpecularAlpha;
  bool terrain;
  std::array<float, 3> terrainParams;

  // BGEM specific fields
  bool blood;
  bool effectLighting;
  bool falloff;
  bool falloffColor;
  bool grayscaleToPaletteAlpha;
  bool soft;
  std::array<float, 3> baseColor = {1, 1, 1};
  float baseColorScale = 1.f;
  std::array<float, 4> falloffParams;
  float lightingInfluence;
  uint8_t envMapMinLod;
  float softDepth;
  bool effectPbrSpecular;
};